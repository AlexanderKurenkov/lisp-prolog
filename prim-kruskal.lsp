; ==================================================================
; реализация алгоритма Прима-Краскала на Lisp
; ==================================================================
; создает множество для элемента x с помощью хэш-таблицы
(defun make-set (x)
	; создает пустую хэш-таблицу и присваивает ее переменной table
  	(let ((table (make-hash-table)))
		; добавляет в хэш-таблицу ключ x со значением t
		(setf (gethash x table) t)
		; возвращает хэш-таблицу table
		table))

; находит множество, содержащие указанный элемент
(defun find-set (x sets)
  	; ищет множество в списке sets, содержащее элемент x
  	(find-if
		; анонимная функция (lambda), которая проверяет,
		; содержит ли множество set элемент x
		(lambda (set)
			; возвращает значение, соответствующее
			; ключу x в хэш-таблице set
			(gethash x set))
		; список множеств для поиска
		sets))

; объединяет два множества и обновляет список множеств
(defun union-sets (set1 set2 sets)
	; проходит по всем элементам множества set2
	; и добавляет их в множество set1
	(maphash
		; анонимная функция (lambda), которая вызывается
		; для каждой пары ключ-значение в хэш-таблице set2
		(lambda (key value)
		; устанавливает для ключа key в хэш-таблице set1
		; значение value из хэш-таблицы set2
		(setf (gethash key set1) value))
		; применяет анонимную функцию ко всем парам ключ-значение в set2
		set2)

	; удаляет множество set2 из списка множеств
  	(remove set2 sets)
  	; добавляет объединенное множество set1 в список множеств
  	(append sets (list set1)))

; функция, реализующая алгоритм Прима-Краскала
; входные параметры - список ребер и вершин графа
(defun prim-kruskal (edges vertices)
  (let* (
	; переменная для хранения отсортированных ребера
	(sorted-edges
	; сортирует список ребер по возрастанию их весов
	(sort edges #'<
		; указывает, что сортировка должна основываться на значении ключа
		:key
		; анонимная функция (lambda), извлекающая вес ребра из списка
		(lambda (list)
			; извлекает третий элемент (вес ребра) из списка
			(nth 2 list))))
	; создает множество для каждой из вершин
	(sets (mapcar #'make-set vertices))
	; создает пустой список для хранения ребер минимального остовного дерева
	(mst '()))

	; итерация по отсортированным ребрам
    (dolist (edge sorted-edges mst)
      (let* (
		; инициализирует переменные u и v вершинами текущего ребра edge
	  	(u (first edge))
		(v (second edge))

		; находит множество, содержащее вершину u, из списка множеств sets
		(set-u (find-set u sets))
		(set-v (find-set v sets)))

		; проверяет, принадлежат ли вершины разным множествам
        (unless (equal set-u set-v)
			; добавляет ребро к МОД, если оно соединяет два разных множества
          	(setf mst (cons edge mst))
			; объединяет множества set-u и set-v и присваивает их sets
          	(setf sets (union-sets set-u set-v sets)))))))

; тестирование
(let*
    (
	; список ребер
    (edges '(
		(A B 6)  ; ребро между вершинами A и B с весом 6
		(A D 7)
		(A E 4)

		(B C 9)
		(B F 7)

		(C F 7)
		(C I 2)

		(D E 8)
		(D G 4)
		(D J 6)

		(E F 6)
		(E G 9)

		(F I 10)
		(F H 9)

		(G H 10)
		(G J 6)

		(H I 5)
		(H K 7)
		(H L 7)

		(J K 6)

		(K L 4)
		))
    ; список вершин графа
    (vertices '(A B C D E F G H I J K L))
    ; вычисление минимального остовного дерева с использованием алгоритма Прима-Краскала
    (mst (prim-kruskal edges vertices)))
    ; вывод МОД на экран
    (print mst))